export declare const TAKEABLE_DICTIONARY: {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const TAKEABLE: () => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const SHIFTABLE: () => {
    shiftable: boolean;
};
export declare const createEnsemble: (name: any, ensembleMembers: any, dict: any) => any;
export declare const MERCH: (value: any, locs: any) => {
    canBeSoldHere(loc: any): any;
    getBuyingPrice(char: any): any;
    getPrice(): any;
    getSellingPrice(char: any): number;
    isForSale(loc: any): any;
    isLocatedAt(loc: any, situation: any): any;
    msgPurchase: string;
    msgSell: string;
    price: any;
    purchase(options: any): any;
    purchaseScript(options: any, char: any, cost: any): number;
    sell(options: any): any;
};
export declare const COUNTABLE: (countableLocs: any) => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const WEARABLE: (wear_layer: any, slots: any) => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const CONTAINER: (openable: any) => {
    close(options: any): boolean;
    msgClose: string;
    msgCloseAndLock: string;
    msgLock: string;
    msgOpen: string;
    msgUnlock: string;
    open(options: any): boolean;
    openMsg(options: any): void;
};
export declare const SURFACE: () => {};
export declare const OPENABLE: (alreadyOpen: any) => {
    close(options: any): boolean;
    msgClose: string;
    msgCloseAndLock: string;
    msgLock: string;
    msgOpen: string;
    msgUnlock: string;
    open(options: any): boolean;
    openMsg(options: any): void;
};
export declare const LOCKED_WITH: (keyNames: any) => {
    keyNames: any;
    lock(options: any): any;
    locked: boolean;
    lockwith(options: any): void;
    testKeys(char: any, toLock: any): any;
    unlock(options: any): any;
    unlockwith(options: any): void;
};
export declare const LOCKED_DOOR: (key: any, loc1: any, loc2: any, name1: any, name2: any) => {
    keyNames: any;
    lock(options: any): any;
    locked: boolean;
    lockwith(options: any): void;
    testKeys(char: any, toLock: any): any;
    unlock(options: any): any;
    unlockwith(options: any): void;
    close(options: any): boolean;
    msgClose: string;
    msgCloseAndLock: string;
    msgLock: string;
    msgOpen: string;
    msgUnlock: string;
    open(options: any): boolean;
    openMsg(options: any): void;
};
export declare const KEY: () => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const READABLE: (mustBeHeld: any) => {};
export declare const FURNITURE: (options: any) => any;
export declare const SWITCHABLE: (alreadyOn: any, nameModifier: any) => {};
export declare const COMPONENT: (nameOfWhole: any) => {
    component: boolean;
    isLocatedAt(loc: any, situation: any): any;
    loc: any;
    scenery: boolean;
    take(options: any): boolean;
    takeable: boolean;
};
export declare const EDIBLE: (isLiquid: any) => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
};
export declare const VESSEL: () => {};
export declare const CONSTRUCTION: (componentNames: any) => {};
export declare const ROPE: (length: any, tetheredTo: any) => {
    afterCreation(o: any): void;
    drop(options: any): boolean;
    msgDrop: string;
    msgDropIn: string;
    msgTake: string;
    msgTakeOut: string;
    take(options: any): any;
    takeFromLoc(char: any): any;
    takeable: boolean;
    attachTo(char: any, item: any): void;
    attachVerb: string;
    attachedVerb: string;
    canAttachTo(item: any): any;
    detachFrom(char: any, item: any): void;
    detachVerb: string;
    examineAddendum(): any;
    findAttachable(): any;
    getAttached(): any[];
    handleTieTo(char: any, obj: any): any;
    handleUntieFrom(char: any, obj: any): any;
    isAttachedTo(item: any): boolean;
    isLocatedAt(loc: any, situation: any): any;
    isUltimatelyHeldBy(obj: any): any;
    locs: any[];
    msgAttach: string;
    msgDetach: string;
    msgUnwind: string;
    msgWind: string;
    rope: boolean;
    ropeLength: any;
    tethered: boolean;
    tiedTo1: any;
    useWith(char: any, item: any): boolean;
};
export declare const BUTTON: () => {
    afterCreation(o: any): void;
    button: boolean;
    msgPress: string;
};
export declare const TRANSIT_BUTTON: (nameOfTransit: any, transitDest: any) => {
    afterCreation(o: any): void;
    button: boolean;
    msgPress: string;
};
export declare const ROOM_SET: (setName: any) => {
    roomSet: any;
};
export declare const TRANSIT: (exitDir: any) => {
    afterLoadForTemplate(): void;
    beforeEnter(): void;
    findTransitButton(dest: any): any;
    getTransitButtons(includeHidden: any, includeLocked: any): any;
    getTransitDestButton(): any;
    getTransitDestLocation(): any;
    isTransitHere(char?: import("../types/iquest").IPlayer): boolean;
    mapMoveableLoc: boolean;
    mapRedrawEveryTurn: boolean;
    saveExitDests: boolean;
    setTransitDest(transitButton: any): any;
    transitDoorDir: any;
    transitOfferMenu(): boolean;
    transitUpdate(transitButton: any, callEvent: any): any;
};
export declare const CHARACTER: () => {
    afterCarryList: any[];
    afterCreation(o: any): void;
    canReachThroughThis: () => boolean;
    canSeeThroughThis: () => boolean;
    followers: any[];
    getAgreement(cmdType: any, obj1: any, obj2: any): any;
    getCarrying(): any[];
    getContents: any;
    getHolding(): any;
    getOuterWearable(slot: any): any;
    getStatusDesc(): string | false;
    getWearing(): any;
    handleGiveTo(options: any): any;
    handleMovingFollowers(exit: any): void;
    mentionedTopics: any[];
    moveChar(exit: any): any;
    movingMsg(exit: any): void;
    msg(s: any, params: any): void;
    pause: any;
    testManipulate: () => boolean;
    testMove: () => boolean;
    testPosture: () => boolean;
    testTakeDrop: () => boolean;
    testTalk(): any;
    testTalkFlag: boolean;
};
export declare const PLAYER: () => {
    afterCarryList: any[];
    afterCreation(o: any): void;
    canReachThroughThis: () => boolean;
    canSeeThroughThis: () => boolean;
    followers: any[];
    getAgreement(cmdType: any, obj1: any, obj2: any): any;
    getCarrying(): any[];
    getContents: any;
    getHolding(): any;
    getOuterWearable(slot: any): any;
    getStatusDesc(): string | false;
    getWearing(): any;
    handleGiveTo(options: any): any;
    handleMovingFollowers(exit: any): void;
    mentionedTopics: any[];
    moveChar(exit: any): any;
    movingMsg(exit: any): void;
    msg(s: any, params: any): void;
    pause: any;
    testManipulate: () => boolean;
    testMove: () => boolean;
    testPosture: () => boolean;
    testTakeDrop: () => boolean;
    testTalk(): any;
    testTalkFlag: boolean;
};
export declare const Templates: {
    BUTTON_DICTIONARY: {
        afterCreation(o: any): void;
        button: boolean;
        msgPress: string;
    };
    BUTTON: () => {
        afterCreation(o: any): void;
        button: boolean;
        msgPress: string;
    };
    CHARACTER: () => {
        afterCarryList: any[];
        afterCreation(o: any): void;
        canReachThroughThis: () => boolean;
        canSeeThroughThis: () => boolean;
        followers: any[];
        getAgreement(cmdType: any, obj1: any, obj2: any): any;
        getCarrying(): any[];
        getContents: any;
        getHolding(): any;
        getOuterWearable(slot: any): any;
        getStatusDesc(): string | false;
        getWearing(): any;
        handleGiveTo(options: any): any;
        handleMovingFollowers(exit: any): void;
        mentionedTopics: any[];
        moveChar(exit: any): any;
        movingMsg(exit: any): void;
        msg(s: any, params: any): void;
        pause: any;
        testManipulate: () => boolean;
        testMove: () => boolean;
        testPosture: () => boolean;
        testTakeDrop: () => boolean;
        testTalk(): any;
        testTalkFlag: boolean;
    };
    COMPONENT: (nameOfWhole: any) => {
        component: boolean;
        isLocatedAt(loc: any, situation: any): any;
        loc: any;
        scenery: boolean;
        take(options: any): boolean;
        takeable: boolean;
    };
    CONSTRUCTION: (componentNames: any) => {};
    COUNTABLE: (countableLocs: any) => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    EDIBLE: (isLiquid: any) => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    FURNITURE: (options: any) => any;
    KEY: () => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    LOCKED_DOOR: (key: any, loc1: any, loc2: any, name1: any, name2: any) => {
        keyNames: any;
        lock(options: any): any;
        locked: boolean;
        lockwith(options: any): void;
        testKeys(char: any, toLock: any): any;
        unlock(options: any): any;
        unlockwith(options: any): void;
        close(options: any): boolean;
        msgClose: string;
        msgCloseAndLock: string;
        msgLock: string;
        msgOpen: string;
        msgUnlock: string;
        open(options: any): boolean;
        openMsg(options: any): void;
    };
    LOCKED_WITH: (keyNames: any) => {
        keyNames: any;
        lock(options: any): any;
        locked: boolean;
        lockwith(options: any): void;
        testKeys(char: any, toLock: any): any;
        unlock(options: any): any;
        unlockwith(options: any): void;
    };
    MERCH: (value: any, locs: any) => {
        canBeSoldHere(loc: any): any;
        getBuyingPrice(char: any): any;
        getPrice(): any;
        getSellingPrice(char: any): number;
        isForSale(loc: any): any;
        isLocatedAt(loc: any, situation: any): any;
        msgPurchase: string;
        msgSell: string;
        price: any;
        purchase(options: any): any;
        purchaseScript(options: any, char: any, cost: any): number;
        sell(options: any): any;
    };
    OPENABLE_DICTIONARY: {
        close(options: any): boolean;
        msgClose: string;
        msgCloseAndLock: string;
        msgLock: string;
        msgOpen: string;
        msgUnlock: string;
        open(options: any): boolean;
        openMsg(options: any): void;
    };
    OPENABLE: (alreadyOpen: any) => {
        close(options: any): boolean;
        msgClose: string;
        msgCloseAndLock: string;
        msgLock: string;
        msgOpen: string;
        msgUnlock: string;
        open(options: any): boolean;
        openMsg(options: any): void;
    };
    PLAYER: () => {
        afterCarryList: any[];
        afterCreation(o: any): void;
        canReachThroughThis: () => boolean;
        canSeeThroughThis: () => boolean;
        followers: any[];
        getAgreement(cmdType: any, obj1: any, obj2: any): any;
        getCarrying(): any[];
        getContents: any;
        getHolding(): any;
        getOuterWearable(slot: any): any;
        getStatusDesc(): string | false;
        getWearing(): any;
        handleGiveTo(options: any): any;
        handleMovingFollowers(exit: any): void;
        mentionedTopics: any[];
        moveChar(exit: any): any;
        movingMsg(exit: any): void;
        msg(s: any, params: any): void;
        pause: any;
        testManipulate: () => boolean;
        testMove: () => boolean;
        testPosture: () => boolean;
        testTakeDrop: () => boolean;
        testTalk(): any;
        testTalkFlag: boolean;
    };
    READABLE: (mustBeHeld: any) => {};
    ROOM_SET: (setName: any) => {
        roomSet: any;
    };
    ROPE: (length: any, tetheredTo: any) => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
        attachTo(char: any, item: any): void;
        attachVerb: string;
        attachedVerb: string;
        canAttachTo(item: any): any;
        detachFrom(char: any, item: any): void;
        detachVerb: string;
        examineAddendum(): any;
        findAttachable(): any;
        getAttached(): any[];
        handleTieTo(char: any, obj: any): any;
        handleUntieFrom(char: any, obj: any): any;
        isAttachedTo(item: any): boolean;
        isLocatedAt(loc: any, situation: any): any;
        isUltimatelyHeldBy(obj: any): any;
        locs: any[];
        msgAttach: string;
        msgDetach: string;
        msgUnwind: string;
        msgWind: string;
        rope: boolean;
        ropeLength: any;
        tethered: boolean;
        tiedTo1: any;
        useWith(char: any, item: any): boolean;
    };
    SHIFTABLE: () => {
        shiftable: boolean;
    };
    SURFACE: () => {};
    TAKEABLE_DICTIONARY: {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    TAKEABLE: () => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    TRANSIT_BUTTON: (nameOfTransit: any, transitDest: any) => {
        afterCreation(o: any): void;
        button: boolean;
        msgPress: string;
    };
    TRANSIT: (exitDir: any) => {
        afterLoadForTemplate(): void;
        beforeEnter(): void;
        findTransitButton(dest: any): any;
        getTransitButtons(includeHidden: any, includeLocked: any): any;
        getTransitDestButton(): any;
        getTransitDestLocation(): any;
        isTransitHere(char?: import("../types/iquest").IPlayer): boolean;
        mapMoveableLoc: boolean;
        mapRedrawEveryTurn: boolean;
        saveExitDests: boolean;
        setTransitDest(transitButton: any): any;
        transitDoorDir: any;
        transitOfferMenu(): boolean;
        transitUpdate(transitButton: any, callEvent: any): any;
    };
    VESSEL: () => {};
    WEARABLE: (wear_layer: any, slots: any) => {
        afterCreation(o: any): void;
        drop(options: any): boolean;
        msgDrop: string;
        msgDropIn: string;
        msgTake: string;
        msgTakeOut: string;
        take(options: any): any;
        takeFromLoc(char: any): any;
        takeable: boolean;
    };
    createEnsemble: (name: any, ensembleMembers: any, dict: any) => any;
};
//# sourceMappingURL=_templates.d.ts.map